{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About 3DC # Digital Design & Development Club (3DC) is an official Fifth-Row club affilliated with ISTD Pillar at SUTD . We are also a Developer Student Club (DSC) supported by Google and a member of the OpenNodes Campus Collective . Stay connected: Telegram Community: 3DC Family YouTube Channel: SUTD 3DC Instagram: @sutd3dc Twitch: www.twitch.tv/3dcdsc GitHub: github.com/3DCdsc Collaboration with Google # Developer Student Clubs are university based community groups for students interested in Google developer technologies. Students from all undergraduate or graduate programs with an interest in growing as a developer are welcome. By joining a DSC, students grow their knowledge in a peer-to-peer learning environment and build solutions for local businesses and their community. In short, DSC is a worldwide community supported by Google. Our 3DC DSC at SUTD is proud to be a part of this community. We are seeking to empower students in their journey of undergraduate/graduate education. By joining our DSC, students will be able to build up their professional and personal skills, get access to Google Developer resources, and work together to build solutions for local problems in a peer-to-peer learning environment. Collaboration with OpenNodes # OpenNodes is an initiative started by Tribe and IMDA Singapore, and is supported by more than 30 leading global corporates and government agencies with 3DC running SUTD\u2019s branch of Opennodes. The aim is to foster greater collaboration between various stakeholders within the tech ecosystem. OpenNodes Campus Collective is an extension of these efforts, and will be the first time students from various universities across Singapore will be brought together for career opportunities and education resources. Opennodes connects students with projects from companies like IBM and WeBank to give students industry exposure. It will also be pushing out educational workshops for students to learn technical and consulting skills. For more information on ongoing projects and news, please visit this website Collaboration with ISTD # We are the only Fifth-Row under ISTD pillar, we organise events in collaboration with ISTD at i3 Lab (Building 1, Level 6).","title":"About 3DC"},{"location":"#about-3dc","text":"Digital Design & Development Club (3DC) is an official Fifth-Row club affilliated with ISTD Pillar at SUTD . We are also a Developer Student Club (DSC) supported by Google and a member of the OpenNodes Campus Collective . Stay connected: Telegram Community: 3DC Family YouTube Channel: SUTD 3DC Instagram: @sutd3dc Twitch: www.twitch.tv/3dcdsc GitHub: github.com/3DCdsc","title":"About 3DC"},{"location":"#collaboration-with-google","text":"Developer Student Clubs are university based community groups for students interested in Google developer technologies. Students from all undergraduate or graduate programs with an interest in growing as a developer are welcome. By joining a DSC, students grow their knowledge in a peer-to-peer learning environment and build solutions for local businesses and their community. In short, DSC is a worldwide community supported by Google. Our 3DC DSC at SUTD is proud to be a part of this community. We are seeking to empower students in their journey of undergraduate/graduate education. By joining our DSC, students will be able to build up their professional and personal skills, get access to Google Developer resources, and work together to build solutions for local problems in a peer-to-peer learning environment.","title":"Collaboration with Google"},{"location":"#collaboration-with-opennodes","text":"OpenNodes is an initiative started by Tribe and IMDA Singapore, and is supported by more than 30 leading global corporates and government agencies with 3DC running SUTD\u2019s branch of Opennodes. The aim is to foster greater collaboration between various stakeholders within the tech ecosystem. OpenNodes Campus Collective is an extension of these efforts, and will be the first time students from various universities across Singapore will be brought together for career opportunities and education resources. Opennodes connects students with projects from companies like IBM and WeBank to give students industry exposure. It will also be pushing out educational workshops for students to learn technical and consulting skills. For more information on ongoing projects and news, please visit this website","title":"Collaboration with OpenNodes"},{"location":"#collaboration-with-istd","text":"We are the only Fifth-Row under ISTD pillar, we organise events in collaboration with ISTD at i3 Lab (Building 1, Level 6).","title":"Collaboration with ISTD"},{"location":"3DC_Membership/","text":"How to Become a 3DC Member # Last Updated Valid Until 23 Sep 2020 01 Jan 2021 Why Join 3DC? # Everyone can participate in 3DC-organised events with or without being a member of 3DC, we also extend our events to other local universities from time to time. We are an open community. However, we do have 3 groups of people within our 3DC Family. Non-members - You can participate in 3DC events freely, no commitments, but also no Fifth-Row record. 3DC Members - You can participate in 3DC events based on your preference, get more involved in projects/ workshops/ Hackathons. You will get the official Fifth-Row records on your Fifth-Row transcript. 3DC Core Team - We organize events, we host Hackathons, we build communities and everything behind the scene. You will get leadership experience and strong records on your Fifth-Row records and your R\u00e9sum\u00e9. The rest of the page tells you how to become a 3DC Members . If you are interested to join 3DC Core Team , please also check this out. 3 Pathways to Gain Membership # You can choose one of the following 3 pathways to become a 3DC member. (ps: The requirements are not that hard to achieve, and you can definitely make it if you keen to!) Project Workshop Hackthon Pathway 1: Do a Project with 3DC # Doing practical software projects is the best way to learn programming, software development, and computer science. We encourage you to do a software development projects with 3DC, that means you get unlimited support from the 3DC community; we will assign you a mentor from our core team to guide you along the way; You get to showcase your finished project on 3DC's website, get exposures and opportunities. What kind of \"project\" can I do? # Don't be afraid, this \"project\" can be anything at any scale, we just want to encourage you to learn with the community. These projects can be: Self-Initiated (Come up with your own idea.) Mentor-Suggested (You can ask for ideas if you can't think of any.) School-proposed (Sometimes you can work with the school to serve real-world needs by building applications.) Pathway 2: Organise a Workshop with 3DC # If you have passion about certain technical topics that you wanna share it with your peers, or if you are passionate about teaching and helping others. You can cooperate with 3DC and organize a workshop/ lecture/ sharing session. Teaching others is the best way to reinforce your knowledge at any discipline. 3DC can help you with: Event application & administrative matters Event publicity & announcement Workshop content refinement, quality control Video recording/steaming TA supports You can gain: Workshop directing experience Official fifth-row record 3DC membership for a year What kind of \"workshop\" can I do? # Note: Topic of workshop/ lecture/ sharing session is not limited at all, you can pick any topic of your like, present it at any level of difficulty of your like. We only wish that you are passionate about what you are sharing, and we wish the topic to be as diverse as possible. For workshops, it should engage participants with hands-on activities, the pace of the workshop should be as slow as possible. Lecturing time versus hands-on activity time should be around 50:50. Some example topics for workshops may look like: How to build your first website How to build a native iOS App with SwiftUI How to build a Todo App using ReactJS For lectures, you can have fewer interactions with the audience, you don't need to design any hands-on activities. Some topics suit for lecture may look like: What is vim and why you should give it a try What are the best practices in using Vue.JS What is parallelism in Python and how do you use it. For sharing sessions, you can share about your internship experience, UROP experience, job-finding experience. It should come with a longer Q&A time. Some example topics for inspiration: Start-up or Big Corp, which one should you choose? How to prepare for technical interview Undergraduate research 101 - UROP experience sharing Pathway 3: Join a Hackathon with 3DC # Team up with anyone in the 3DC Community, represent 3DC and participate in a hackathon.","title":"How to Become a 3DC Member"},{"location":"3DC_Membership/#how-to-become-a-3dc-member","text":"Last Updated Valid Until 23 Sep 2020 01 Jan 2021","title":"How to Become a 3DC Member"},{"location":"3DC_Membership/#why-join-3dc","text":"Everyone can participate in 3DC-organised events with or without being a member of 3DC, we also extend our events to other local universities from time to time. We are an open community. However, we do have 3 groups of people within our 3DC Family. Non-members - You can participate in 3DC events freely, no commitments, but also no Fifth-Row record. 3DC Members - You can participate in 3DC events based on your preference, get more involved in projects/ workshops/ Hackathons. You will get the official Fifth-Row records on your Fifth-Row transcript. 3DC Core Team - We organize events, we host Hackathons, we build communities and everything behind the scene. You will get leadership experience and strong records on your Fifth-Row records and your R\u00e9sum\u00e9. The rest of the page tells you how to become a 3DC Members . If you are interested to join 3DC Core Team , please also check this out.","title":"Why Join 3DC?"},{"location":"3DC_Membership/#3-pathways-to-gain-membership","text":"You can choose one of the following 3 pathways to become a 3DC member. (ps: The requirements are not that hard to achieve, and you can definitely make it if you keen to!) Project Workshop Hackthon","title":"3 Pathways to Gain Membership"},{"location":"3DC_Membership/#pathway-1-do-a-project-with-3dc","text":"Doing practical software projects is the best way to learn programming, software development, and computer science. We encourage you to do a software development projects with 3DC, that means you get unlimited support from the 3DC community; we will assign you a mentor from our core team to guide you along the way; You get to showcase your finished project on 3DC's website, get exposures and opportunities.","title":"Pathway 1: Do a Project with 3DC"},{"location":"3DC_Membership/#what-kind-of-project-can-i-do","text":"Don't be afraid, this \"project\" can be anything at any scale, we just want to encourage you to learn with the community. These projects can be: Self-Initiated (Come up with your own idea.) Mentor-Suggested (You can ask for ideas if you can't think of any.) School-proposed (Sometimes you can work with the school to serve real-world needs by building applications.)","title":"What kind of \"project\" can I do?"},{"location":"3DC_Membership/#pathway-2-organise-a-workshop-with-3dc","text":"If you have passion about certain technical topics that you wanna share it with your peers, or if you are passionate about teaching and helping others. You can cooperate with 3DC and organize a workshop/ lecture/ sharing session. Teaching others is the best way to reinforce your knowledge at any discipline. 3DC can help you with: Event application & administrative matters Event publicity & announcement Workshop content refinement, quality control Video recording/steaming TA supports You can gain: Workshop directing experience Official fifth-row record 3DC membership for a year","title":"Pathway 2: Organise a Workshop with 3DC"},{"location":"3DC_Membership/#what-kind-of-workshop-can-i-do","text":"Note: Topic of workshop/ lecture/ sharing session is not limited at all, you can pick any topic of your like, present it at any level of difficulty of your like. We only wish that you are passionate about what you are sharing, and we wish the topic to be as diverse as possible. For workshops, it should engage participants with hands-on activities, the pace of the workshop should be as slow as possible. Lecturing time versus hands-on activity time should be around 50:50. Some example topics for workshops may look like: How to build your first website How to build a native iOS App with SwiftUI How to build a Todo App using ReactJS For lectures, you can have fewer interactions with the audience, you don't need to design any hands-on activities. Some topics suit for lecture may look like: What is vim and why you should give it a try What are the best practices in using Vue.JS What is parallelism in Python and how do you use it. For sharing sessions, you can share about your internship experience, UROP experience, job-finding experience. It should come with a longer Q&A time. Some example topics for inspiration: Start-up or Big Corp, which one should you choose? How to prepare for technical interview Undergraduate research 101 - UROP experience sharing","title":"What kind of \"workshop\" can I do?"},{"location":"3DC_Membership/#pathway-3-join-a-hackathon-with-3dc","text":"Team up with anyone in the 3DC Community, represent 3DC and participate in a hackathon.","title":"Pathway 3: Join a Hackathon with 3DC"},{"location":"Join_3DC_Core/","text":"How to Join 3DC Core Team # Last Updated Valid Until 23 Sep 2020 01 Jan 2021 Why Join 3DC Core Team? # We organise talks, workshops, Hackthons; We build communities; We advocate for Open Source; We give back to community using technology. If you are interested in joining 3DC's Core Team (EXCO), please fill in this form to let us know. We will contact you from there.","title":"How to Join 3DC Core Team"},{"location":"Join_3DC_Core/#how-to-join-3dc-core-team","text":"Last Updated Valid Until 23 Sep 2020 01 Jan 2021","title":"How to Join 3DC Core Team"},{"location":"Join_3DC_Core/#why-join-3dc-core-team","text":"We organise talks, workshops, Hackthons; We build communities; We advocate for Open Source; We give back to community using technology. If you are interested in joining 3DC's Core Team (EXCO), please fill in this form to let us know. We will contact you from there.","title":"Why Join 3DC Core Team?"},{"location":"Workshop_2020/","text":"Workshops in 2020 # Upcoming Workshops # Introduction to ReactJS and Web Development Workshop # Target Audience: Beginners in web development. Prerequisite: Basic knowledge on Dictionary , List , Functions , Loops . Date: 26th October 2020 , Monday of Week 7 (Recess week) Time: 3.00 - 5.00 PM (2 hours) Instructor: Bryce (Class of 2024) Delivering Format: Hybrid (Offline + Online concurrently) Physical venue: SUTD i3 Lab (Building 1, Level 6) (With 20 ppl cap, only open for SUTD Freshmore & Hostel Residents) Virtual venue: YouTube or/and Twitch Stream Sign up for either physical or virtual session from here now! Introduction to Python and Programming Workshop # Target Audience: All Freshmore students who aren't comfortable with Python or with no prior programming experience. Prerequisite: None Session Dates: S1: Introduction to Programming & Python Basics Date: 27th October 2020 (Tuesday of Week 7) (Recess week) Time: 1.30 - 4.30 PM (3 hours) S2: More on Python Programming Date: 12th November 2020 (Thursday of Week 9) Time: 7.00 - 9.00 PM (2 hours) S3: Python Programming & Review for Computational Thinking for Design Date: 26th November 2020 (Thursday of Week 11) Time: 7.00 - 9.00 PM (2 hours) Delivering Format: Hybrid (Offline + Online concurrently) Physical venue: SUTD i3 Lab (Building 1, Level 6) (With 20 ppl cap, only open for SUTD Freshmore & Hostel Residents) Virtual venue: YouTube or/and Twitch Stream Sign up for either physical or virtual session from here now!","title":"Workshops in 2020"},{"location":"Workshop_2020/#workshops-in-2020","text":"","title":"Workshops in 2020"},{"location":"Workshop_2020/#upcoming-workshops","text":"","title":"Upcoming Workshops"},{"location":"Workshop_2020/#introduction-to-reactjs-and-web-development-workshop","text":"Target Audience: Beginners in web development. Prerequisite: Basic knowledge on Dictionary , List , Functions , Loops . Date: 26th October 2020 , Monday of Week 7 (Recess week) Time: 3.00 - 5.00 PM (2 hours) Instructor: Bryce (Class of 2024) Delivering Format: Hybrid (Offline + Online concurrently) Physical venue: SUTD i3 Lab (Building 1, Level 6) (With 20 ppl cap, only open for SUTD Freshmore & Hostel Residents) Virtual venue: YouTube or/and Twitch Stream Sign up for either physical or virtual session from here now!","title":"Introduction to ReactJS and Web Development Workshop"},{"location":"Workshop_2020/#introduction-to-python-and-programming-workshop","text":"Target Audience: All Freshmore students who aren't comfortable with Python or with no prior programming experience. Prerequisite: None Session Dates: S1: Introduction to Programming & Python Basics Date: 27th October 2020 (Tuesday of Week 7) (Recess week) Time: 1.30 - 4.30 PM (3 hours) S2: More on Python Programming Date: 12th November 2020 (Thursday of Week 9) Time: 7.00 - 9.00 PM (2 hours) S3: Python Programming & Review for Computational Thinking for Design Date: 26th November 2020 (Thursday of Week 11) Time: 7.00 - 9.00 PM (2 hours) Delivering Format: Hybrid (Offline + Online concurrently) Physical venue: SUTD i3 Lab (Building 1, Level 6) (With 20 ppl cap, only open for SUTD Freshmore & Hostel Residents) Virtual venue: YouTube or/and Twitch Stream Sign up for either physical or virtual session from here now!","title":"Introduction to Python and Programming Workshop"},{"location":"recess_week_challenge/","text":"Recess Week Challenge 2020: A Minecraft Story # Last updated: 19/10/2020 3DC Recess Week Challenge is a great way to kill off spare time, or to learn a new skill during this recess week! Follow through our Minecraft-themed story to learn to do some basic coding, solve algorithm questions, try out your hand at deploying a cloud-based web application, compete in a time-based coding challenge and win prizes! Timeline # The 3DC recess week challenge comprises three main parts: Cloud-based lab to deploy a simple web application with REST API (24/10/20) Daily Hackerrank own-time-own-target coding challenge (26/10/20 - 28/10/20) Time-based coding challenge on Hackerrank (30/10/20) You do not have to complete the challenges or labs on the day they are released. Just submit them before the deadline on 31/10/20 1500 (Saturday). However, those who complete the time-based coding challenge faster will rank higher, so try to start working on that challenge as soon as it is released! Prizes # 1st Place : Raspberry Pi Model 4B+ 4GB RAM Prize for Top 5 Freshmore Students : $5 GrabFood Voucher each Prize for Top 5 Non-ISTD Pillar-Year Students : $5 GrabFood Voucher each Prize for Top 5 ISTD Students : $5 GrabFood Voucher each Registration and Links # Register for the challenge here . Check out the leaderboard, or submit your cloud-based lab over here . All links to the 3DC challenges will be posted here. Challenge Difficulty Release Date Points Teaser Challenge: Steve and Sheep Medium 23/10/20 (Friday) N/A Cloud-based Lab: Sheep-as-a-Service Medium 24/10/20 (Saturday) 20:00 200 Hackerrank Challenge 1: Steve's Wheat Farm Challenging 26/10/20 (Monday) 09:00 100 Hackerrank Challenge 2: Steve vs Prof Oka! Easy 27/10/20 (Tuesday) 09:00 100 Hackerrank Challenge 3: Irritgating Steve Medium 28/10/20 (Wednesday) 09:00 100 Hackerrank Timed Challenge: Enderdragon Fight! Hard 30/10/20 (Friday) 14:30 200 Scoring Guidelines # Both the Hackerrank non-timed and timed challenges will be graded by Hackerrank's automated scoring system. The Cloud-based challenge will be graded automatically. Please use this link to test your website. Placement is graded based on total score. In the event of a tie, timing for the hackerrank timed challenge will be used as a tiebreaker.","title":"Recess Week Challenge 2020: A Minecraft Story"},{"location":"recess_week_challenge/#recess-week-challenge-2020-a-minecraft-story","text":"Last updated: 19/10/2020 3DC Recess Week Challenge is a great way to kill off spare time, or to learn a new skill during this recess week! Follow through our Minecraft-themed story to learn to do some basic coding, solve algorithm questions, try out your hand at deploying a cloud-based web application, compete in a time-based coding challenge and win prizes!","title":"Recess Week Challenge 2020: A Minecraft Story"},{"location":"recess_week_challenge/#timeline","text":"The 3DC recess week challenge comprises three main parts: Cloud-based lab to deploy a simple web application with REST API (24/10/20) Daily Hackerrank own-time-own-target coding challenge (26/10/20 - 28/10/20) Time-based coding challenge on Hackerrank (30/10/20) You do not have to complete the challenges or labs on the day they are released. Just submit them before the deadline on 31/10/20 1500 (Saturday). However, those who complete the time-based coding challenge faster will rank higher, so try to start working on that challenge as soon as it is released!","title":"Timeline"},{"location":"recess_week_challenge/#prizes","text":"1st Place : Raspberry Pi Model 4B+ 4GB RAM Prize for Top 5 Freshmore Students : $5 GrabFood Voucher each Prize for Top 5 Non-ISTD Pillar-Year Students : $5 GrabFood Voucher each Prize for Top 5 ISTD Students : $5 GrabFood Voucher each","title":"Prizes"},{"location":"recess_week_challenge/#registration-and-links","text":"Register for the challenge here . Check out the leaderboard, or submit your cloud-based lab over here . All links to the 3DC challenges will be posted here. Challenge Difficulty Release Date Points Teaser Challenge: Steve and Sheep Medium 23/10/20 (Friday) N/A Cloud-based Lab: Sheep-as-a-Service Medium 24/10/20 (Saturday) 20:00 200 Hackerrank Challenge 1: Steve's Wheat Farm Challenging 26/10/20 (Monday) 09:00 100 Hackerrank Challenge 2: Steve vs Prof Oka! Easy 27/10/20 (Tuesday) 09:00 100 Hackerrank Challenge 3: Irritgating Steve Medium 28/10/20 (Wednesday) 09:00 100 Hackerrank Timed Challenge: Enderdragon Fight! Hard 30/10/20 (Friday) 14:30 200","title":"Registration and Links"},{"location":"recess_week_challenge/#scoring-guidelines","text":"Both the Hackerrank non-timed and timed challenges will be graded by Hackerrank's automated scoring system. The Cloud-based challenge will be graded automatically. Please use this link to test your website. Placement is graded based on total score. In the event of a tie, timing for the hackerrank timed challenge will be used as a tiebreaker.","title":"Scoring Guidelines"},{"location":"workshop_guide/","text":"Guide to Host Your First Workshop with 3DC # Hello friend, since you are reading this, I suppose you want to find out how to host your own workshop with the help and support from 3DC. Don't worry, it is not hard to get started. Generally, things should to be determined from the start: Topic (Anything! Technical / Non-technical) Scope (Rough) Intended Audience (Beginners / Experienced / Advanced) Event Type (Workshop / Lecture / Sharing) Date of Event (Rough) You can think about above items on your own and then share your plan with us (3DC), but if you have any doubts about what might be suitable for your workshop, feel free to talk to us even without having answers to the above items, we can discuss them together. So after you have the scope of the workshop planned out, you can start to prepare for you workshop material and we can work on administrative stuff together. For workshop material: We usually open source all of our materials (slides, notes, sample code etc) on GitHub. For hands-on workshops, it is important to prepare a pre-workshop material for your audience if any software installation/ environment setup is required for your hands-on activity. Pre-workshop material can be used to get everyone on the same page as well by presenting background information/ foundation knowledge. If would be best if you can get all of the materials ready on GitHub before the actual date of event, so we can send the link to the attendees via email before the event. Format of releasing materials: .md (MarkDown) for main materials & notes, .pdf for slides, and source code (if any). For admin & publicity: Ideally, workshop should be planned 2-month ahead , because any event to be hosted in SUTD needs to submit Event Proposal 1-month prior to the actual date of event. Before Event: Event Proposal will be drafted and submitted by 3DC on behalf of you, and you will be the person-in-charge and the \"Workshop Director\" for this event. TA recruitment. 3DC will work with you on event publicity, which includes: Email (e-Poster) Website Social Media (3DC instagram etc) During Event: Recording / streaming TA Moderation After Event: Feedback form Post-workshop review AAR Submission","title":"Guide to Host Your First Workshop with 3DC"},{"location":"workshop_guide/#guide-to-host-your-first-workshop-with-3dc","text":"Hello friend, since you are reading this, I suppose you want to find out how to host your own workshop with the help and support from 3DC. Don't worry, it is not hard to get started. Generally, things should to be determined from the start: Topic (Anything! Technical / Non-technical) Scope (Rough) Intended Audience (Beginners / Experienced / Advanced) Event Type (Workshop / Lecture / Sharing) Date of Event (Rough) You can think about above items on your own and then share your plan with us (3DC), but if you have any doubts about what might be suitable for your workshop, feel free to talk to us even without having answers to the above items, we can discuss them together. So after you have the scope of the workshop planned out, you can start to prepare for you workshop material and we can work on administrative stuff together. For workshop material: We usually open source all of our materials (slides, notes, sample code etc) on GitHub. For hands-on workshops, it is important to prepare a pre-workshop material for your audience if any software installation/ environment setup is required for your hands-on activity. Pre-workshop material can be used to get everyone on the same page as well by presenting background information/ foundation knowledge. If would be best if you can get all of the materials ready on GitHub before the actual date of event, so we can send the link to the attendees via email before the event. Format of releasing materials: .md (MarkDown) for main materials & notes, .pdf for slides, and source code (if any). For admin & publicity: Ideally, workshop should be planned 2-month ahead , because any event to be hosted in SUTD needs to submit Event Proposal 1-month prior to the actual date of event. Before Event: Event Proposal will be drafted and submitted by 3DC on behalf of you, and you will be the person-in-charge and the \"Workshop Director\" for this event. TA recruitment. 3DC will work with you on event publicity, which includes: Email (e-Poster) Website Social Media (3DC instagram etc) During Event: Recording / streaming TA Moderation After Event: Feedback form Post-workshop review AAR Submission","title":"Guide to Host Your First Workshop with 3DC"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/","text":"Recess Week Challenge Cloud-Based Lab: Sheep-as-a-Service (SaaS) # The story so far... # If you have tried out the teaser challenge released on Friday, you would have helped our main character, Steve to set up his sheep farm! Thanks to all your help, Steve is now happily shearing wool from his sheep! Now, Steve wants to sell wool to other Minecrafters. He needs your help to set up a system that helps customers calculate the price of the wool they wish to buy! Introduction # Welcome to 3DC's cloud-based lab! This lab has the following aims: Create a web-app with a working backend API The web-app will serve a very simple webpage as well that makes use of the backend API Deploy the web-app onto the cloud. TODO: Explain API In this case, our backend API will return a response containing the total price of the wool that the requester requests for. For this lab tutorial, we will be using Flask (a Python backend framework). We will be deploying our app to ( Amazon Web Services(AWS) ) Elastic Beanstalk. Setting up your Local Environment # Installing Python # Please refer to the Python Website for instructions to install Python3 if you don't already have Python3 installed. Installing Flask # Open a Terminal/Command Prompt on your computer. (Here's an example for Windows) Now, install Flask by typing the following into your command line. (Note: It might be pip or pip3 on your computer depending on how you installed python) pip install Flask We now have Flask installed! ( Credits :Original Installation Instructions from Flask Website ) Creating our first Flask Web Application! # For now, we will create a Flask Web Application that runs on our local machine first. We will deploy this application to the cloud later. Setting up the workspace # Let us start by creating a folder for our cloud lab. In this case I will name this folder cloud_lab . We will create a Python file which will act as the source code for our Flask application. I will name this file sheep_shop.py , since this will be steve's sheep shop (or wool shop)! We will also create a HTML file which will be our home webpage for Steve's Sheep Shop! Steve's customers will access this webpage to check the price of the wool they want to buy! I will be creating a new file called index.html and placing it under the templates folder inside our cloud_lab folder. If you followed the steps above correctly, your directory structure should look like the following: cloud_lab | sheep_shop.py | \u2514\u2500\u2500\u2500templates | index.html Creating the webpage # Since this tutorial is meant to be simple, we will only be using HTML, no CSS or Javascript Open your empty index.html file using your favourite text editor (you can use Notepad). To make things simple, we have provided some very simple sample code with comments. Simply paste this code into your file and replace the fields the file tells you to replace. <!doctype html> < html > < head > <!-- Fill in the title to appear as your tab title below --> < title > YOUR TITLE HERE </ title > </ head > < body > <!-- Fill in the main header title for your webpage below --> < h1 > YOUR HEADER TITLE HERE </ h1 > <!-- Fill in the subtitle for your webpage below --> < h2 > YOUR SUBTITLE HERE </ h2 > <!-- The below code adds a form to our webpage --> <!-- This form calls our Python file when the button is pressed --> < form id = \"request_form\" action = \"{{ url_for('request_price') }}\" method = \"POST\" > <!-- The <label> elements add labels for each field --> <!-- The <input> elements add fields for our forms --> < label for = \"num_red_wool\" > Number of Red Wool: </ label >< br > < input type = \"number\" id = \"num_red_wool\" name = \"num_red_wool\" >< br > < label for = \"num_green_wool\" > Number of Green Wool: </ label >< br > < input type = \"number\" id = \"num_green_wool\" name = \"num_green_wool\" >< br > < label for = \"num_blue_wool\" > Number of Blue Wool: </ label >< br > < input type = \"number\" id = \"num_blue_wool\" name = \"num_blue_wool\" >< br > <!-- The below represents the submit button for our form --> < input type = \"submit\" value = \"Calculate Price\" > </ form > </ body > </ html > Note that the <input> elements in the form have the name attribute assigned to them. This name attribute allows us to identify which field is which when we pass the form over to the Python code later on. In the <form> element, the action attribute causes the form to submit a HTTP request to our Python Flask Application (which acts as the server). If you are interested to know, the method attribute specifies the kind of HTTP request that is sent to the server. A POST request is usually used to send data to a server. Make sure to save your file! You can open this HTML file in your web browser to see what it looks like! Setting up the Local Flask Server # What we have just done is created a simple static webpage! However, the webpage by itself right now doesnt really do anything. It can't actually calculate anything! Usually, you could simply add some javascript to add some interactive functionality to your webpage. However, we Steve realises he has a problem. The cost of each red wool, green wool and blue wool is changing all the time! Steve does not want to implement the logic for calculating the cost for the wool on his webpage. Instead, he wants to leave the calculation logic to a server, where he could also do many other things! Now of course, Steve's goal to calculate price is a very simple task, however, a server becomes much more important when you have databases and complicated logic involved. Static web pages by themselves are not made to handle complex server logic or concurrency. Open sheep_shop.py in your favourite text editor(e.g. Notepad, VScode) or IDE (e.g. Spyder, PyCharm). Paste the following template code with comments into your Python file and replace the part to calculate the total wool price. from flask import Flask , render_template , request , jsonify red_wool_price = 100 # Sets the price of a red wool to 100. DO NOT MODIFY green_wool_price = 10 # Sets the price of a green wool to 10. DO NOT MODIFY blue_wool_price = 1 # Sets the price of a green wool to 1. DO NOT MODIFY app = Flask ( __name__ ) # Creates a Flask application @app . route ( '/' ) def index (): # When the user navigates to <your_site_url>/, the index.html page renders return render_template ( 'index.html' ) @app . route ( '/request_price' , methods = [ 'POST' ]) def request_price (): # The HTML page sends a HTTP request to this endpoint # containing the wool numbers that the customer keyed in # Now we extract the actual wool numbers from the HTTP request. num_red_wool = int ( request . form . get ( 'num_red_wool' )) num_green_wool = int ( request . form . get ( 'num_green_wool' )) num_blue_wool = int ( request . form . get ( 'num_blue_wool' )) # Replace the 0 with the logic to calulcate the total price of the wools # Hint: Total price is given by the sum of the number of each type of wool # multiplied by their individual price. The variables containig the price of # each wool has already been provided at the start of this file price = 0 # Now we return a JSON object containing the price of the object # as a reponse return jsonify ({ 'price' : price }) if __name__ == '__main__' : app . run () Basically, the Flask app shows the user the webpage when the user navigates to the root directory of the website. In the second part of the flask app, there is a HTTP endpoint (you can think of it like a function) that handles the submitted form data from our index.html webpage. If you recall from the HTML file, we had a line < form id = \"request_form\" action = \"{{ url_for('request_price') }}\" method = \"POST\" > This action attribute tells the form to send the form data to the the url of the function with the name request_price in our flask app. The request_price function then takes the form data containing the number of wools, calculates the total price and returns a JSON object containing this total price in its response. Running the Local Flask Server # To start up the server, open up a terminal, and navigate to the cloud_lab directory. Simply start the server by typing in the terminal (warning: depending on your setup, the command may be python3 instead of python ) python sheep_shop.py You should see output on the terminal similar to the following: * Serving Flask app \"sheep_shop\" (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) Great, our flask app is now running! In your web browser, navigate to the url stated in the terminal output (usually http://127.0.0.1:5000/ ), and you should see your main webpage again, but this time served from your local Flask server! We can test out our webpage and price calculation. For example, fill in the number of the red, green and blue wools to be 1, 2 and 3 respectively, then click on the calculate button. You should now be redirected to another page that looks like this: On Firefox: On Chrome/Edge: Congratulations, you have created your first working Flask application with a webpage and HTTP endpoint! Let us see how we can deploy this application to the cloud so the anyone on the internet case access it! (and so we can award you marks for your lab) Deploying a Flask Web Application to the Cloud (AWS) # We will be deploying our Flask server to AWS Elastic Beanstalk, a managed cloud service that will help to host the Flask application for us. Note that the options we choose in this lab should not incur any monetary costs, as we are using the 'free tier' of services. 0. Prepare our application # To upload to Elastic Beanstalk, we need to do some additional configurations and setup. First, Elastic Beanstalk requires our Python Flask file to be called application.py , so go ahead rename that file. The name of the Flask app variable in our Python file also needs to be called application , so go ahead and replace ALL occurances of app with application . IMPORTANT: Be careful! You need to change the app.route to application.route and the app.run() to application.run() Second, Elastic Beanstalk requires a requirements.txt in the same folder as the application.py , so that it knows what dependencies it needs to install. Normally, we would use pip freeze to help us find out the requirements of our virtual environment. However, since we did not create virtual environment, this would just return all the dependencies installed on our computer, instead of just the ones required for the Flask Application. So, create a new file called requirements.txt and paste the contents inside: click==7.1.2 Flask==1.1.2 itsdangerous==1.1.0 Jinja2==2.11.2 MarkupSafe==1.1.1 Werkzeug==1.0.1 We will need to zip our application to upload to AWS later. There are other ways to upload our application, e.g. using S3 or Github, but we will just zip the application for now. (I will zip the contents cloud_lab folder to cloud_lab.zip ) IMPORTANT: Make sure there is no extra base folder in your zip file. The moment you open the zip file, the Python file and requirements file and templates folder should be in the root directory. 1. Create an AWS Account # If you do not have an AWS Account already, sign up for a free AWS account here: https://aws.amazon.com/. If you have an account, just log in. 2. Go to the AWS Elastic Beanstalk Console # In the AWS Management Console, click on Services in the top left corner, and click on Elastic Beanstalk . Then, click on Create Application 3. Fill in Application Details # You should now see a form to fill in your application details. Fill in the following: For Application Name , just fill in whatever you want (e.g. Sheep Shop ) Leave Application Tags empty For Platform , choose Python , then Python3.7 running on 64bit Amazon Linux 2 for the Platform branch, then 3.1.2 for the platform version (or which is given) For Application Code , choose to upload your code. For Source Code Origin , choose Choose file , then choose to upload the zip file we created for our application earlier (e.g. cloud_lab.zip ). For Application code tags , leave it alone, then click on Create Application 4. Wait for Application Deployment # You should now see something like this. AWS Elastic Beanstalk is now deploying your application, give it a while for it to be ready. Meanwhile, go make yourself some coffee or something! After some time, the deployment should be complete, and you should see the following: To verify the webpage is indeed working, navigate to the link (as circled in the image). You should see your working webpage. Try calculating the price of wools, and it should be working! 5. You're Done! # That wasn't so difficult was it? Deploying your first web application onto the cloud. Once you're ready, submit your cloud based lab here . We strongly encourage you to explore other options for creating a web-app (e.g. Express/Spring/ASP.NET/Django), as well as the other cloud providers (E.g. Microsoft Azure, Google Cloud Platform) and the different services they have to offer!","title":"Recess Week Challenge Cloud-Based Lab: Sheep-as-a-Service (SaaS)"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#recess-week-challenge-cloud-based-lab-sheep-as-a-service-saas","text":"","title":"Recess Week Challenge Cloud-Based Lab: Sheep-as-a-Service (SaaS)"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#the-story-so-far","text":"If you have tried out the teaser challenge released on Friday, you would have helped our main character, Steve to set up his sheep farm! Thanks to all your help, Steve is now happily shearing wool from his sheep! Now, Steve wants to sell wool to other Minecrafters. He needs your help to set up a system that helps customers calculate the price of the wool they wish to buy!","title":"The story so far..."},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#introduction","text":"Welcome to 3DC's cloud-based lab! This lab has the following aims: Create a web-app with a working backend API The web-app will serve a very simple webpage as well that makes use of the backend API Deploy the web-app onto the cloud. TODO: Explain API In this case, our backend API will return a response containing the total price of the wool that the requester requests for. For this lab tutorial, we will be using Flask (a Python backend framework). We will be deploying our app to ( Amazon Web Services(AWS) ) Elastic Beanstalk.","title":"Introduction"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#setting-up-your-local-environment","text":"","title":"Setting up your Local Environment"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#installing-python","text":"Please refer to the Python Website for instructions to install Python3 if you don't already have Python3 installed.","title":"Installing Python"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#installing-flask","text":"Open a Terminal/Command Prompt on your computer. (Here's an example for Windows) Now, install Flask by typing the following into your command line. (Note: It might be pip or pip3 on your computer depending on how you installed python) pip install Flask We now have Flask installed! ( Credits :Original Installation Instructions from Flask Website )","title":"Installing Flask"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#creating-our-first-flask-web-application","text":"For now, we will create a Flask Web Application that runs on our local machine first. We will deploy this application to the cloud later.","title":"Creating our first Flask Web Application!"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#setting-up-the-workspace","text":"Let us start by creating a folder for our cloud lab. In this case I will name this folder cloud_lab . We will create a Python file which will act as the source code for our Flask application. I will name this file sheep_shop.py , since this will be steve's sheep shop (or wool shop)! We will also create a HTML file which will be our home webpage for Steve's Sheep Shop! Steve's customers will access this webpage to check the price of the wool they want to buy! I will be creating a new file called index.html and placing it under the templates folder inside our cloud_lab folder. If you followed the steps above correctly, your directory structure should look like the following: cloud_lab | sheep_shop.py | \u2514\u2500\u2500\u2500templates | index.html","title":"Setting up the workspace"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#creating-the-webpage","text":"Since this tutorial is meant to be simple, we will only be using HTML, no CSS or Javascript Open your empty index.html file using your favourite text editor (you can use Notepad). To make things simple, we have provided some very simple sample code with comments. Simply paste this code into your file and replace the fields the file tells you to replace. <!doctype html> < html > < head > <!-- Fill in the title to appear as your tab title below --> < title > YOUR TITLE HERE </ title > </ head > < body > <!-- Fill in the main header title for your webpage below --> < h1 > YOUR HEADER TITLE HERE </ h1 > <!-- Fill in the subtitle for your webpage below --> < h2 > YOUR SUBTITLE HERE </ h2 > <!-- The below code adds a form to our webpage --> <!-- This form calls our Python file when the button is pressed --> < form id = \"request_form\" action = \"{{ url_for('request_price') }}\" method = \"POST\" > <!-- The <label> elements add labels for each field --> <!-- The <input> elements add fields for our forms --> < label for = \"num_red_wool\" > Number of Red Wool: </ label >< br > < input type = \"number\" id = \"num_red_wool\" name = \"num_red_wool\" >< br > < label for = \"num_green_wool\" > Number of Green Wool: </ label >< br > < input type = \"number\" id = \"num_green_wool\" name = \"num_green_wool\" >< br > < label for = \"num_blue_wool\" > Number of Blue Wool: </ label >< br > < input type = \"number\" id = \"num_blue_wool\" name = \"num_blue_wool\" >< br > <!-- The below represents the submit button for our form --> < input type = \"submit\" value = \"Calculate Price\" > </ form > </ body > </ html > Note that the <input> elements in the form have the name attribute assigned to them. This name attribute allows us to identify which field is which when we pass the form over to the Python code later on. In the <form> element, the action attribute causes the form to submit a HTTP request to our Python Flask Application (which acts as the server). If you are interested to know, the method attribute specifies the kind of HTTP request that is sent to the server. A POST request is usually used to send data to a server. Make sure to save your file! You can open this HTML file in your web browser to see what it looks like!","title":"Creating the webpage"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#setting-up-the-local-flask-server","text":"What we have just done is created a simple static webpage! However, the webpage by itself right now doesnt really do anything. It can't actually calculate anything! Usually, you could simply add some javascript to add some interactive functionality to your webpage. However, we Steve realises he has a problem. The cost of each red wool, green wool and blue wool is changing all the time! Steve does not want to implement the logic for calculating the cost for the wool on his webpage. Instead, he wants to leave the calculation logic to a server, where he could also do many other things! Now of course, Steve's goal to calculate price is a very simple task, however, a server becomes much more important when you have databases and complicated logic involved. Static web pages by themselves are not made to handle complex server logic or concurrency. Open sheep_shop.py in your favourite text editor(e.g. Notepad, VScode) or IDE (e.g. Spyder, PyCharm). Paste the following template code with comments into your Python file and replace the part to calculate the total wool price. from flask import Flask , render_template , request , jsonify red_wool_price = 100 # Sets the price of a red wool to 100. DO NOT MODIFY green_wool_price = 10 # Sets the price of a green wool to 10. DO NOT MODIFY blue_wool_price = 1 # Sets the price of a green wool to 1. DO NOT MODIFY app = Flask ( __name__ ) # Creates a Flask application @app . route ( '/' ) def index (): # When the user navigates to <your_site_url>/, the index.html page renders return render_template ( 'index.html' ) @app . route ( '/request_price' , methods = [ 'POST' ]) def request_price (): # The HTML page sends a HTTP request to this endpoint # containing the wool numbers that the customer keyed in # Now we extract the actual wool numbers from the HTTP request. num_red_wool = int ( request . form . get ( 'num_red_wool' )) num_green_wool = int ( request . form . get ( 'num_green_wool' )) num_blue_wool = int ( request . form . get ( 'num_blue_wool' )) # Replace the 0 with the logic to calulcate the total price of the wools # Hint: Total price is given by the sum of the number of each type of wool # multiplied by their individual price. The variables containig the price of # each wool has already been provided at the start of this file price = 0 # Now we return a JSON object containing the price of the object # as a reponse return jsonify ({ 'price' : price }) if __name__ == '__main__' : app . run () Basically, the Flask app shows the user the webpage when the user navigates to the root directory of the website. In the second part of the flask app, there is a HTTP endpoint (you can think of it like a function) that handles the submitted form data from our index.html webpage. If you recall from the HTML file, we had a line < form id = \"request_form\" action = \"{{ url_for('request_price') }}\" method = \"POST\" > This action attribute tells the form to send the form data to the the url of the function with the name request_price in our flask app. The request_price function then takes the form data containing the number of wools, calculates the total price and returns a JSON object containing this total price in its response.","title":"Setting up the Local Flask Server"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#running-the-local-flask-server","text":"To start up the server, open up a terminal, and navigate to the cloud_lab directory. Simply start the server by typing in the terminal (warning: depending on your setup, the command may be python3 instead of python ) python sheep_shop.py You should see output on the terminal similar to the following: * Serving Flask app \"sheep_shop\" (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) Great, our flask app is now running! In your web browser, navigate to the url stated in the terminal output (usually http://127.0.0.1:5000/ ), and you should see your main webpage again, but this time served from your local Flask server! We can test out our webpage and price calculation. For example, fill in the number of the red, green and blue wools to be 1, 2 and 3 respectively, then click on the calculate button. You should now be redirected to another page that looks like this: On Firefox: On Chrome/Edge: Congratulations, you have created your first working Flask application with a webpage and HTTP endpoint! Let us see how we can deploy this application to the cloud so the anyone on the internet case access it! (and so we can award you marks for your lab)","title":"Running the Local Flask Server"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#deploying-a-flask-web-application-to-the-cloud-aws","text":"We will be deploying our Flask server to AWS Elastic Beanstalk, a managed cloud service that will help to host the Flask application for us. Note that the options we choose in this lab should not incur any monetary costs, as we are using the 'free tier' of services.","title":"Deploying a Flask Web Application to the Cloud (AWS)"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#0-prepare-our-application","text":"To upload to Elastic Beanstalk, we need to do some additional configurations and setup. First, Elastic Beanstalk requires our Python Flask file to be called application.py , so go ahead rename that file. The name of the Flask app variable in our Python file also needs to be called application , so go ahead and replace ALL occurances of app with application . IMPORTANT: Be careful! You need to change the app.route to application.route and the app.run() to application.run() Second, Elastic Beanstalk requires a requirements.txt in the same folder as the application.py , so that it knows what dependencies it needs to install. Normally, we would use pip freeze to help us find out the requirements of our virtual environment. However, since we did not create virtual environment, this would just return all the dependencies installed on our computer, instead of just the ones required for the Flask Application. So, create a new file called requirements.txt and paste the contents inside: click==7.1.2 Flask==1.1.2 itsdangerous==1.1.0 Jinja2==2.11.2 MarkupSafe==1.1.1 Werkzeug==1.0.1 We will need to zip our application to upload to AWS later. There are other ways to upload our application, e.g. using S3 or Github, but we will just zip the application for now. (I will zip the contents cloud_lab folder to cloud_lab.zip ) IMPORTANT: Make sure there is no extra base folder in your zip file. The moment you open the zip file, the Python file and requirements file and templates folder should be in the root directory.","title":"0. Prepare our application"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#1-create-an-aws-account","text":"If you do not have an AWS Account already, sign up for a free AWS account here: https://aws.amazon.com/. If you have an account, just log in.","title":"1. Create an AWS Account"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#2-go-to-the-aws-elastic-beanstalk-console","text":"In the AWS Management Console, click on Services in the top left corner, and click on Elastic Beanstalk . Then, click on Create Application","title":"2. Go to the AWS Elastic Beanstalk Console"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#3-fill-in-application-details","text":"You should now see a form to fill in your application details. Fill in the following: For Application Name , just fill in whatever you want (e.g. Sheep Shop ) Leave Application Tags empty For Platform , choose Python , then Python3.7 running on 64bit Amazon Linux 2 for the Platform branch, then 3.1.2 for the platform version (or which is given) For Application Code , choose to upload your code. For Source Code Origin , choose Choose file , then choose to upload the zip file we created for our application earlier (e.g. cloud_lab.zip ). For Application code tags , leave it alone, then click on Create Application","title":"3. Fill in Application Details"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#4-wait-for-application-deployment","text":"You should now see something like this. AWS Elastic Beanstalk is now deploying your application, give it a while for it to be ready. Meanwhile, go make yourself some coffee or something! After some time, the deployment should be complete, and you should see the following: To verify the webpage is indeed working, navigate to the link (as circled in the image). You should see your working webpage. Try calculating the price of wools, and it should be working!","title":"4. Wait for Application Deployment"},{"location":"Recess_Week_Challenge_Stuff/cloud_based_lab/#5-youre-done","text":"That wasn't so difficult was it? Deploying your first web application onto the cloud. Once you're ready, submit your cloud based lab here . We strongly encourage you to explore other options for creating a web-app (e.g. Express/Spring/ASP.NET/Django), as well as the other cloud providers (E.g. Microsoft Azure, Google Cloud Platform) and the different services they have to offer!","title":"5. You're Done!"},{"location":"Recess_Week_Challenge_Stuff/guide/","text":"Recess Week Challenge Hackerrank Guide # Typically, the first line of the question specifies the parameters for the input, such as the number of lines, values of variables. It is usually followed by a specified number of lines containing data separated by spaces. Input Example (2 represents the number of lines to be followed by \\((x)\\) , 1 8 3 is one line of data (to be read into first line of list), 4 5 6 is the second line of data (to be read into second line of list)) 2 1 8 3 4 5 6 Output Example 1 2 3 Python3 Guide # To read the first line of input, x = int ( input ()) # The int() is used to convert input from a string to integer To read the subsequent 2 lines of input all_lists = [] for j in range ( x ): my_list = [] my_list = [ int ( i ) for i in input () . split ()] # A list of integers all_lists . append ( my_list ) For printing output print ( a , b , c ) C++ Guide # You will require the following libraries #include <iostream> // To read from input and to print output #include <array> // To read the tuple #include <vector> // To read the lines of input To read the first line of input int x ; std :: cin >> x ; To read the subsequent 2 lines of input std :: vector < int > v ( x ); // Initialise vector with size x for ( int i = 0 ; i < x ; ++ i ) { std :: cin >> a1 >> a2 >> a3 ; v . at ( i ) = std :: array < int , 3 > { a1 , a2 , a3 }; // Assign element at i index of vector to array of inputs } To print to output std :: cout << a << b << c ;","title":"Recess Week Challenge Hackerrank Guide"},{"location":"Recess_Week_Challenge_Stuff/guide/#recess-week-challenge-hackerrank-guide","text":"Typically, the first line of the question specifies the parameters for the input, such as the number of lines, values of variables. It is usually followed by a specified number of lines containing data separated by spaces. Input Example (2 represents the number of lines to be followed by \\((x)\\) , 1 8 3 is one line of data (to be read into first line of list), 4 5 6 is the second line of data (to be read into second line of list)) 2 1 8 3 4 5 6 Output Example 1 2 3","title":"Recess Week Challenge Hackerrank Guide"},{"location":"Recess_Week_Challenge_Stuff/guide/#python3-guide","text":"To read the first line of input, x = int ( input ()) # The int() is used to convert input from a string to integer To read the subsequent 2 lines of input all_lists = [] for j in range ( x ): my_list = [] my_list = [ int ( i ) for i in input () . split ()] # A list of integers all_lists . append ( my_list ) For printing output print ( a , b , c )","title":"Python3 Guide"},{"location":"Recess_Week_Challenge_Stuff/guide/#c-guide","text":"You will require the following libraries #include <iostream> // To read from input and to print output #include <array> // To read the tuple #include <vector> // To read the lines of input To read the first line of input int x ; std :: cin >> x ; To read the subsequent 2 lines of input std :: vector < int > v ( x ); // Initialise vector with size x for ( int i = 0 ; i < x ; ++ i ) { std :: cin >> a1 >> a2 >> a3 ; v . at ( i ) = std :: array < int , 3 > { a1 , a2 , a3 }; // Assign element at i index of vector to array of inputs } To print to output std :: cout << a << b << c ;","title":"C++ Guide"},{"location":"Recess_Week_Challenge_Stuff/q1_hints/","text":"Q1 Hints # Try to use hints only when you really need help! The hints are arranged in order. Hint 1 There is an obvious brute force algorithm to do this question (iterate through each block, then iterate through the number of adjacent blocks to add the light level), but is this efficient? You will need to spend O(n * m) time for this algorithm, where n is the number of blocks, and m is the maximum brightness level of a light source. You are possibly iterating through each block so many times! Perhaps you might find [prefix sum arrays](https://www.geeksforgeeks.org/prefix-sum-array-implementation-applications-competitive-programming/) to be of use! Hint 2 Break down the problem into smaller sub-problems! Try to solve a simpler version of the problem first! - How do we get the brightness level of each block, without taking into account the light decay yet? (i.e. the light sources are infinitely powerful) - Then, how do we take into account the light decay of each light source? Hint 3 You will only need linear time corresponding to the number of blocks to solve this problem! Perhaps you could combine prefix sum arrays with dividing the problem into smaller problems? Multiple prefix sum arrays? Hint 4 What effect does performing prefix sum of on an array TWICE do? Might it be useful in this question? Especially for the falloff?","title":"Q1 Hints"},{"location":"Recess_Week_Challenge_Stuff/q1_hints/#q1-hints","text":"Try to use hints only when you really need help! The hints are arranged in order. Hint 1 There is an obvious brute force algorithm to do this question (iterate through each block, then iterate through the number of adjacent blocks to add the light level), but is this efficient? You will need to spend O(n * m) time for this algorithm, where n is the number of blocks, and m is the maximum brightness level of a light source. You are possibly iterating through each block so many times! Perhaps you might find [prefix sum arrays](https://www.geeksforgeeks.org/prefix-sum-array-implementation-applications-competitive-programming/) to be of use! Hint 2 Break down the problem into smaller sub-problems! Try to solve a simpler version of the problem first! - How do we get the brightness level of each block, without taking into account the light decay yet? (i.e. the light sources are infinitely powerful) - Then, how do we take into account the light decay of each light source? Hint 3 You will only need linear time corresponding to the number of blocks to solve this problem! Perhaps you could combine prefix sum arrays with dividing the problem into smaller problems? Multiple prefix sum arrays? Hint 4 What effect does performing prefix sum of on an array TWICE do? Might it be useful in this question? Especially for the falloff?","title":"Q1 Hints"},{"location":"Recess_Week_Challenge_Stuff/q1_sol/","text":"Q1: Solution and Afterthoughts # Steve's Wheat Farm is arguably the most difficult problem in the entire recess week challenge, so much that Q2 was made easier to allow participants more time to solve Q1. However, Steve's Wheat Farm is actually not that difficult of a problem if approached correctly. There is really only one advanced programming concept: The Prefix Sum Array (Refer to hints on what is a Prefix Sum Array). Straightforward (and Naive) # Let us explore the problem step by step. Let's use an example to visualise 11 0 0 0 0 3 0 3 0 0 0 0 The straightfowrward approach is to Visit each block in order (* denotes the current block we are on) If there is a light source on that block Add the brightness to that block (we shall just skip to the first light source) To the block to the right of the current block, add brightness level of the source block, subtracted by 1. Repeat this process as we continue going right, subtracting 1 more each time until we reach brightness level 0, or there are no more blocks on the right. Repeat above steps for the right side of the block. After visiting the first light source: 0 0 1 2 3 2 4 0 0 0 0 After visiting the second light source: 0 0 1 2 4 4 4 2 1 0 0 This gives us a time complexity of \\(O(n * B_{max})\\) , where \\(n\\) is the number of blocks and \\(B_{max}\\) is the max brightness level of a source. Naive approach in Python3 n = int ( input ()) brightness = [ 0 ] * n raws = input () . split () # Store the source inputs in an array for i in range ( n ): # Iterate through source inputs, and add them to the final brightness array. source = int ( raws [ i ]) brightness [ i ] += source d = 1 # Represents the current distance away from the source for j in range ( source - 1 , 0 , - 1 ): # Decrement brightness level by 1 for each block away from source if i + d < n : # If the dth block on right side of the source block is within the given blocks # Add brightness level due to source block at that block brightness [ i + d ] += j if i - d >= 0 : # If dth block on left side of the source block is within the given blocks # Add brightness level due to source block at that block brightness [ i - d ] += j d += 1 # Increment distance at each iteration # Now loop through the array to find the number of blocks that meet # the optimal brightness condition count = 0 for source in brightness : if ( source >= 10000 and source <= 30000000 ): count += 1 print ( count ) The problem with the naive apporach # We are potentially visiting each block so many times if every block has a source of \\(B_{max}\\) brightness level. In particular, the step where we \"spread\" out the light from the light source is incredibly repetitive. is there a way to do things better? A better approach # We can use the prefix sum array approach, where we \"jot down\" the main parameters for the operations that we will need to perform later. For example for any given light source, we can describe its impact on the result array by breaking it down into a few segments: The resultant brightness level at any block is the arithmetic sum of the individual resultant brightness levels due to individual light sources around it (something like superposition) The resultant brightness level of a block due to a source falls off over distance. Conversely, we can rephrase the above statement to: (Taking a left-to-right approach) The resultant brightness level of a block due to a source increases (by 1 per block) as we approach the source, and falls back down(by 1 per block) to zero as we get further away from the source. Of course, take note the resultant brightness level of a block due to a source can never be less than zero. This means that at \\(brightnesslevel\\) distance to the left of the source, we should start to increase the brightness level by 1 every block Notice that in terms of a prefix sum array, this can be represented by adding +1 to the first block where the brightness level is non-zero (initalise a new array first) Adding +1 to the first block where brightness level is non-zero 0 0 1 0 1 0 0 0 0 0 0 Then when we get to the block right after the source, we should reverse this trend (i.e. make it decreasing). Notice that we can change the prefix sum trend from +1 to -1, by adding -2 to the block right after the light source. Adding -2 to the block to the immediate right of the source: 0 0 1 0 1 -2 0 -2 0 0 0 Eventually, we should stop this decreasing trend right after the block where the brightness level due to this source should become zero. This means we should counter the -1 prefix sum trend by adding +1 to the block right after where the brightness level due to the light source should become zero. 0 0 1 0 1 -2 0 -2 1 0 1 Note that the step where we add +1 to start the increasing trend, the index of the source may be negative. To fix that, we can Add +1 to the first element of the prefix sum array to denote the increasing trend Add the brightness level of the first block (due to the current light source) subtracted by 1, to sort of shared \\(base\\) variable. We will add this \\(base\\) variable back to the array later. Since we are going from left to right, we don't have to do this treatment for the part on the right of the light source. All that is left now is to evaluate the prefix sum of our array base = 0 0 0 1 1 2 0 0 -2 0 -1 -1 0 Performing prefix sum once will give us the realised total increasing/decreasing trend for each block. Add the \\(base\\) variable back to the first element of the array, since we are going to evaluate the final total brightness levels due to the starting value and the increasing/decreasing trends now, and we need the starting brightness value at the first block. Perform prefix sum yet another time on the array. The first element will represent the starting brightness, and apply the trend for the next block at every next block, together with the base value from the previous block. 0 0 1 2 4 4 4 2 1 0 0 Efficiency of improved algorithm # Notice that we only iterate through the array twice, and during the first set of iteration, we perform a maximum of three array-lookup operations (of \\(O(1)\\) time complexity) per block, which gives us a total linear time complexity of \\(O(n)\\) ! The full solution (Python3) can be found below. Python 3 Full Solution with Prefix Sum def prefixSum ( arr ): # Returns array where each element is the cumulative sum of the elements # up to its current index in the original array arr2 = [ 0 ] * len ( arr ) arr2 [ 0 ] = arr [ 0 ] for i in range ( 1 , len ( arr )): arr2 [ i ] = arr2 [ i - 1 ] + arr [ i ] return arr2 n = int ( input ()) sources = [ 0 ] * n # Base Array to perform prefix sum on. raws = [ int ( i ) for i in input () . split ()] base = 0 # Base variable to store the starting value of the array for i in range ( n ): source = raws [ i ] if source == 0 : # If the source is zero, there is no need to do anything continue if i - source + 1 >= 0 : # Check if the first non-zero brightness level block is within the array bounds # If it is within bounds, add +1 to indicate the start of the increasing trend sources [ i - source + 1 ] += 1 else : # Otherwise, add +1 to the first element of the array to indicate the trend # and also store the starting brightness level at the first block at base variable sources [ 0 ] += 1 base += source - i - 1 if i + 1 < n : # If the source is non-zero and not the last block # Indicate that the trend should be reversed at the next block sources [ i + 1 ] -= 2 if i + 1 + source < n : # And indicate where this reverse trend should end # This should be where the brightness level decreases to zero sources [ i + 1 + source ] += 1 # Prefix Sum once gives us the array of total increasing/decreasing trends at each block pfSources = prefixSum ( sources ) # Add base back to the array to set our starting value pfSources [ 0 ] += base # Prefix sum again to apply the trends from the starting value res = prefixSum ( pfSources ) optimal = 0 # Variable to contain number of optimal blocks for i in range ( n ): # To find the actual light level, add light level of each block due to sources # in both directions, then add cumulative falloff at each block in both directions if ( res [ i ] >= 10000 and res [ i ] < 30000000 ): optimal += 1 print ( optimal )","title":"Q1: Solution and Afterthoughts"},{"location":"Recess_Week_Challenge_Stuff/q1_sol/#q1-solution-and-afterthoughts","text":"Steve's Wheat Farm is arguably the most difficult problem in the entire recess week challenge, so much that Q2 was made easier to allow participants more time to solve Q1. However, Steve's Wheat Farm is actually not that difficult of a problem if approached correctly. There is really only one advanced programming concept: The Prefix Sum Array (Refer to hints on what is a Prefix Sum Array).","title":"Q1: Solution and Afterthoughts"},{"location":"Recess_Week_Challenge_Stuff/q1_sol/#straightforward-and-naive","text":"Let us explore the problem step by step. Let's use an example to visualise 11 0 0 0 0 3 0 3 0 0 0 0 The straightfowrward approach is to Visit each block in order (* denotes the current block we are on) If there is a light source on that block Add the brightness to that block (we shall just skip to the first light source) To the block to the right of the current block, add brightness level of the source block, subtracted by 1. Repeat this process as we continue going right, subtracting 1 more each time until we reach brightness level 0, or there are no more blocks on the right. Repeat above steps for the right side of the block. After visiting the first light source: 0 0 1 2 3 2 4 0 0 0 0 After visiting the second light source: 0 0 1 2 4 4 4 2 1 0 0 This gives us a time complexity of \\(O(n * B_{max})\\) , where \\(n\\) is the number of blocks and \\(B_{max}\\) is the max brightness level of a source. Naive approach in Python3 n = int ( input ()) brightness = [ 0 ] * n raws = input () . split () # Store the source inputs in an array for i in range ( n ): # Iterate through source inputs, and add them to the final brightness array. source = int ( raws [ i ]) brightness [ i ] += source d = 1 # Represents the current distance away from the source for j in range ( source - 1 , 0 , - 1 ): # Decrement brightness level by 1 for each block away from source if i + d < n : # If the dth block on right side of the source block is within the given blocks # Add brightness level due to source block at that block brightness [ i + d ] += j if i - d >= 0 : # If dth block on left side of the source block is within the given blocks # Add brightness level due to source block at that block brightness [ i - d ] += j d += 1 # Increment distance at each iteration # Now loop through the array to find the number of blocks that meet # the optimal brightness condition count = 0 for source in brightness : if ( source >= 10000 and source <= 30000000 ): count += 1 print ( count )","title":"Straightforward (and Naive)"},{"location":"Recess_Week_Challenge_Stuff/q1_sol/#the-problem-with-the-naive-apporach","text":"We are potentially visiting each block so many times if every block has a source of \\(B_{max}\\) brightness level. In particular, the step where we \"spread\" out the light from the light source is incredibly repetitive. is there a way to do things better?","title":"The problem with the naive apporach"},{"location":"Recess_Week_Challenge_Stuff/q1_sol/#a-better-approach","text":"We can use the prefix sum array approach, where we \"jot down\" the main parameters for the operations that we will need to perform later. For example for any given light source, we can describe its impact on the result array by breaking it down into a few segments: The resultant brightness level at any block is the arithmetic sum of the individual resultant brightness levels due to individual light sources around it (something like superposition) The resultant brightness level of a block due to a source falls off over distance. Conversely, we can rephrase the above statement to: (Taking a left-to-right approach) The resultant brightness level of a block due to a source increases (by 1 per block) as we approach the source, and falls back down(by 1 per block) to zero as we get further away from the source. Of course, take note the resultant brightness level of a block due to a source can never be less than zero. This means that at \\(brightnesslevel\\) distance to the left of the source, we should start to increase the brightness level by 1 every block Notice that in terms of a prefix sum array, this can be represented by adding +1 to the first block where the brightness level is non-zero (initalise a new array first) Adding +1 to the first block where brightness level is non-zero 0 0 1 0 1 0 0 0 0 0 0 Then when we get to the block right after the source, we should reverse this trend (i.e. make it decreasing). Notice that we can change the prefix sum trend from +1 to -1, by adding -2 to the block right after the light source. Adding -2 to the block to the immediate right of the source: 0 0 1 0 1 -2 0 -2 0 0 0 Eventually, we should stop this decreasing trend right after the block where the brightness level due to this source should become zero. This means we should counter the -1 prefix sum trend by adding +1 to the block right after where the brightness level due to the light source should become zero. 0 0 1 0 1 -2 0 -2 1 0 1 Note that the step where we add +1 to start the increasing trend, the index of the source may be negative. To fix that, we can Add +1 to the first element of the prefix sum array to denote the increasing trend Add the brightness level of the first block (due to the current light source) subtracted by 1, to sort of shared \\(base\\) variable. We will add this \\(base\\) variable back to the array later. Since we are going from left to right, we don't have to do this treatment for the part on the right of the light source. All that is left now is to evaluate the prefix sum of our array base = 0 0 0 1 1 2 0 0 -2 0 -1 -1 0 Performing prefix sum once will give us the realised total increasing/decreasing trend for each block. Add the \\(base\\) variable back to the first element of the array, since we are going to evaluate the final total brightness levels due to the starting value and the increasing/decreasing trends now, and we need the starting brightness value at the first block. Perform prefix sum yet another time on the array. The first element will represent the starting brightness, and apply the trend for the next block at every next block, together with the base value from the previous block. 0 0 1 2 4 4 4 2 1 0 0","title":"A better approach"},{"location":"Recess_Week_Challenge_Stuff/q1_sol/#efficiency-of-improved-algorithm","text":"Notice that we only iterate through the array twice, and during the first set of iteration, we perform a maximum of three array-lookup operations (of \\(O(1)\\) time complexity) per block, which gives us a total linear time complexity of \\(O(n)\\) ! The full solution (Python3) can be found below. Python 3 Full Solution with Prefix Sum def prefixSum ( arr ): # Returns array where each element is the cumulative sum of the elements # up to its current index in the original array arr2 = [ 0 ] * len ( arr ) arr2 [ 0 ] = arr [ 0 ] for i in range ( 1 , len ( arr )): arr2 [ i ] = arr2 [ i - 1 ] + arr [ i ] return arr2 n = int ( input ()) sources = [ 0 ] * n # Base Array to perform prefix sum on. raws = [ int ( i ) for i in input () . split ()] base = 0 # Base variable to store the starting value of the array for i in range ( n ): source = raws [ i ] if source == 0 : # If the source is zero, there is no need to do anything continue if i - source + 1 >= 0 : # Check if the first non-zero brightness level block is within the array bounds # If it is within bounds, add +1 to indicate the start of the increasing trend sources [ i - source + 1 ] += 1 else : # Otherwise, add +1 to the first element of the array to indicate the trend # and also store the starting brightness level at the first block at base variable sources [ 0 ] += 1 base += source - i - 1 if i + 1 < n : # If the source is non-zero and not the last block # Indicate that the trend should be reversed at the next block sources [ i + 1 ] -= 2 if i + 1 + source < n : # And indicate where this reverse trend should end # This should be where the brightness level decreases to zero sources [ i + 1 + source ] += 1 # Prefix Sum once gives us the array of total increasing/decreasing trends at each block pfSources = prefixSum ( sources ) # Add base back to the array to set our starting value pfSources [ 0 ] += base # Prefix sum again to apply the trends from the starting value res = prefixSum ( pfSources ) optimal = 0 # Variable to contain number of optimal blocks for i in range ( n ): # To find the actual light level, add light level of each block due to sources # in both directions, then add cumulative falloff at each block in both directions if ( res [ i ] >= 10000 and res [ i ] < 30000000 ): optimal += 1 print ( optimal )","title":"Efficiency of improved algorithm"},{"location":"Recess_Week_Challenge_Stuff/q2_sol/","text":"Q2: Solution and Afterthoughts # Question 2 is not difficult at all, and everyone who submitted code managed to solve it. The main objective of Question 2 was to give everyone a breather and more time to solve Question 1. It's all about intuition! # We notice that we have a square room. Then we also notice that if we simply mirror Prof Oka's step every single time (i.e. if he goes Down, we go Right and vice versa), it is impossible for us to copy Prof Oka at all. And since we are mirroring him, we will start at the same point, and end at the same point!","title":"Q2: Solution and Afterthoughts"},{"location":"Recess_Week_Challenge_Stuff/q2_sol/#q2-solution-and-afterthoughts","text":"Question 2 is not difficult at all, and everyone who submitted code managed to solve it. The main objective of Question 2 was to give everyone a breather and more time to solve Question 1.","title":"Q2: Solution and Afterthoughts"},{"location":"Recess_Week_Challenge_Stuff/q2_sol/#its-all-about-intuition","text":"We notice that we have a square room. Then we also notice that if we simply mirror Prof Oka's step every single time (i.e. if he goes Down, we go Right and vice versa), it is impossible for us to copy Prof Oka at all. And since we are mirroring him, we will start at the same point, and end at the same point!","title":"It's all about intuition!"},{"location":"Recess_Week_Challenge_Stuff/q3_hints/","text":"Q3 Hints # Try to use hints only when you really need help! The hints are arranged in order. Hint 1 This can be achieved using a Flood fill algorithm , but you must add your own custom checks regarding the depth level, and change the notion of \"same colour\" to \"obstacle\". Hint 2 Encountering a timeout on your code for more complex cases? Perhaps consider how efficient your current algorithm is. Does it constantly excessively waste time computing something that would be overwritten later? Is there a way to minimize this wastage in computational time?","title":"Q3 Hints"},{"location":"Recess_Week_Challenge_Stuff/q3_hints/#q3-hints","text":"Try to use hints only when you really need help! The hints are arranged in order. Hint 1 This can be achieved using a Flood fill algorithm , but you must add your own custom checks regarding the depth level, and change the notion of \"same colour\" to \"obstacle\". Hint 2 Encountering a timeout on your code for more complex cases? Perhaps consider how efficient your current algorithm is. Does it constantly excessively waste time computing something that would be overwritten later? Is there a way to minimize this wastage in computational time?","title":"Q3 Hints"},{"location":"Recess_Week_Challenge_Stuff/q3_sol/","text":"Q3: Solution and Afterthoughts # Question 3 was a more balanced question compared to Question 1 and Question 2, one being really difficult, and the other being really easy. The participant's objective is to take the straightforward approach to Question 3 and try to make it more efficient. Mainly, this was a greedy algorithm question. The base approaches # All the approaches utilise the flood fill algorithm in one way or another. However, it is not too difficult to come up with the flood fill algorithm yourself either. The most straightforward approach is to visit each block one by one from the top left, and then try to visit all blocks adjacent to it (up, down, left, right). If the adjacent block has a depth lower that current depth minus by one, then update that block with current depth minus by one. And visit that block to repeat the algorithm for its adjacent blocks If the adjacent block does not have a depth lower than current depth minus by one, or if it is an obstacle, do nothing, there is no need to update or visit that block If the current depth is zero, just backtrack. The other similar approach is to start from the water source block and run the same above three steps. The problem # Both approaches can be extremely inefficient, possibly having to recompute each block's depth multiple times, which can lead to recomputation of the blocks below it as well. The above approaches are depth-based, going deep into branches right from the start, instead of spreading out slowly. A more efficient, greedy approach # Intuition tells us that blocks closer to the water source block are more likely to be deeper (more water) than blocks further from it. Obstacles may complicate things and the bove may not always hold true as a result, but it is still a good general rule of thumb to follow. Thus, we can try to be greedy by choosing to update blocks that are likely to have a larger water depth first (i.e. blocks closer to the water source), before exploring the ones that are likely to be shallower (i.e. blocks further from the water source). Statistically, this minimizes the chance of us having to re-update later. To do this, we need to explore the blocks by going in a spiral around the water source block. One way to do this is to use a queue . A queue follows a first-in-first-out policy, allowing us to \"remember\" or \"save\" the blocks we want to visit later (i.e. we can store adjacent blocks of the current block we are visiting (that we have recently updated) into the queue), while trying clear the blocks that we have marked for visiting earlier. This queue causes us to go in a spiral pattern, and we are going broad first rather than deep, minimizing our inefficiency. Eventually, the algorithm ends when there are no more blocks in the queue (i.e. no more blocks that we need to visit/update). Python3 Approach for Greedy Queue Algorithm def flood ( grid , r , c , depth , x , y ): # For loop algorithm (function that calls itself) that uses a queue if depth == 1 : # If water depth is one, there is no need to update anything else return Q = [] # Initialise Queue to be empty Q . append (( r , c , depth )) # Add water source block's position and depth to the queue while len ( Q ) != 0 : # While queue is not empty, visit all the blocks in the queue, FIFO ( nx , ny , d ) = Q . pop ( 0 ) # Visit block at the start of the queue for ( i , j ) in [( nx - 1 , ny ), ( nx + 1 , ny ),( nx , ny - 1 ), ( nx , ny + 1 )]: # Try to see if adjacent blocks need to be updated if i < x and i >= 0 and j < y and j >= 0 \\ and grid [ i ][ j ] >= 0 and grid [ i ][ j ] < d - 1 : # If adjacent blocks have lower water depth and current -1 # and are within boundaries grid [ i ][ j ] = d - 1 # Set their new water depth to current depth - 1 Q . append (( i , j , d - 1 )) # Since water depth was updated for that block # Might need to update depth of blocks adjacent to it, so add to queue rows , cols , depth = [ int ( i ) for i in input () . split ()] grid = [[ 0 for i in range ( cols )] for j in range ( rows )] water_r = 0 water_c = 0 for row in range ( rows ): # We store the source block's water depth # Any blocks is an obstacle is marked with -1 # All other blocks are marked as 0 s = input () . split () for col in range ( cols ): if s [ col ] == \"X\" : grid [ row ][ col ] = - 1 elif s [ col ] == \".\" : grid [ row ][ col ] = 0 else : grid [ row ][ col ] = int ( s [ col ]) water_r = row water_c = col flood ( grid , water_r , water_c , depth , rows , cols ) # Result obtained, just convert it into the format requested by qn for row in range ( rows ): for col in range ( cols ): if grid [ row ][ col ] == 0 : print ( '.' , end = \" \" ) elif grid [ row ][ col ] == - 1 : print ( 'X' , end = \" \" ) else : print ( grid [ row ][ col ], end = \" \" ) print () Compare it to the more naive, less greedy approach below. Python3 Solution for depth-first approach def flood ( grid , r , c , depth , x , y ): # Recursive algorithm (function that calls itself) that goes deep first if depth == 1 : return for ( i , j ) in [( r - 1 , c ), ( r + 1 , c ), ( r , c - 1 ), ( r , c + 1 )]: if i < x and i >= 0 and j < y and j >= 0 \\ and grid [ i ][ j ] >= 0 and grid [ i ][ j ] < depth - 1 : flood ( grid , i , j , depth - 1 , x , y ) rows , cols , depth = [ int ( i ) for i in input () . split ()] grid = [[ 0 ] * cols ] * rows water_r = 0 water_c = 0 for row in range ( rows ): s = input () . split () for col in range ( cols ): if s [ col ] == \"X\" : grid [ row ][ col ] = - 1 elif s [ col ] == \".\" : grid [ row ][ col ] = 0 else : grid [ row ][ col ] = int ( s [ col ]) water_r = row water_c = col flood ( grid , water_r , water_c , depth , rows , cols ) for row in range ( rows ): for col in range ( cols ): if grid [ row ][ col ] == 0 : print ( '.' , end = \" \" ) else : print ( grid [ row ][ col ], end = \" \" ) print ()","title":"Q3: Solution and Afterthoughts"},{"location":"Recess_Week_Challenge_Stuff/q3_sol/#q3-solution-and-afterthoughts","text":"Question 3 was a more balanced question compared to Question 1 and Question 2, one being really difficult, and the other being really easy. The participant's objective is to take the straightforward approach to Question 3 and try to make it more efficient. Mainly, this was a greedy algorithm question.","title":"Q3: Solution and Afterthoughts"},{"location":"Recess_Week_Challenge_Stuff/q3_sol/#the-base-approaches","text":"All the approaches utilise the flood fill algorithm in one way or another. However, it is not too difficult to come up with the flood fill algorithm yourself either. The most straightforward approach is to visit each block one by one from the top left, and then try to visit all blocks adjacent to it (up, down, left, right). If the adjacent block has a depth lower that current depth minus by one, then update that block with current depth minus by one. And visit that block to repeat the algorithm for its adjacent blocks If the adjacent block does not have a depth lower than current depth minus by one, or if it is an obstacle, do nothing, there is no need to update or visit that block If the current depth is zero, just backtrack. The other similar approach is to start from the water source block and run the same above three steps.","title":"The base approaches"},{"location":"Recess_Week_Challenge_Stuff/q3_sol/#the-problem","text":"Both approaches can be extremely inefficient, possibly having to recompute each block's depth multiple times, which can lead to recomputation of the blocks below it as well. The above approaches are depth-based, going deep into branches right from the start, instead of spreading out slowly.","title":"The problem"},{"location":"Recess_Week_Challenge_Stuff/q3_sol/#a-more-efficient-greedy-approach","text":"Intuition tells us that blocks closer to the water source block are more likely to be deeper (more water) than blocks further from it. Obstacles may complicate things and the bove may not always hold true as a result, but it is still a good general rule of thumb to follow. Thus, we can try to be greedy by choosing to update blocks that are likely to have a larger water depth first (i.e. blocks closer to the water source), before exploring the ones that are likely to be shallower (i.e. blocks further from the water source). Statistically, this minimizes the chance of us having to re-update later. To do this, we need to explore the blocks by going in a spiral around the water source block. One way to do this is to use a queue . A queue follows a first-in-first-out policy, allowing us to \"remember\" or \"save\" the blocks we want to visit later (i.e. we can store adjacent blocks of the current block we are visiting (that we have recently updated) into the queue), while trying clear the blocks that we have marked for visiting earlier. This queue causes us to go in a spiral pattern, and we are going broad first rather than deep, minimizing our inefficiency. Eventually, the algorithm ends when there are no more blocks in the queue (i.e. no more blocks that we need to visit/update). Python3 Approach for Greedy Queue Algorithm def flood ( grid , r , c , depth , x , y ): # For loop algorithm (function that calls itself) that uses a queue if depth == 1 : # If water depth is one, there is no need to update anything else return Q = [] # Initialise Queue to be empty Q . append (( r , c , depth )) # Add water source block's position and depth to the queue while len ( Q ) != 0 : # While queue is not empty, visit all the blocks in the queue, FIFO ( nx , ny , d ) = Q . pop ( 0 ) # Visit block at the start of the queue for ( i , j ) in [( nx - 1 , ny ), ( nx + 1 , ny ),( nx , ny - 1 ), ( nx , ny + 1 )]: # Try to see if adjacent blocks need to be updated if i < x and i >= 0 and j < y and j >= 0 \\ and grid [ i ][ j ] >= 0 and grid [ i ][ j ] < d - 1 : # If adjacent blocks have lower water depth and current -1 # and are within boundaries grid [ i ][ j ] = d - 1 # Set their new water depth to current depth - 1 Q . append (( i , j , d - 1 )) # Since water depth was updated for that block # Might need to update depth of blocks adjacent to it, so add to queue rows , cols , depth = [ int ( i ) for i in input () . split ()] grid = [[ 0 for i in range ( cols )] for j in range ( rows )] water_r = 0 water_c = 0 for row in range ( rows ): # We store the source block's water depth # Any blocks is an obstacle is marked with -1 # All other blocks are marked as 0 s = input () . split () for col in range ( cols ): if s [ col ] == \"X\" : grid [ row ][ col ] = - 1 elif s [ col ] == \".\" : grid [ row ][ col ] = 0 else : grid [ row ][ col ] = int ( s [ col ]) water_r = row water_c = col flood ( grid , water_r , water_c , depth , rows , cols ) # Result obtained, just convert it into the format requested by qn for row in range ( rows ): for col in range ( cols ): if grid [ row ][ col ] == 0 : print ( '.' , end = \" \" ) elif grid [ row ][ col ] == - 1 : print ( 'X' , end = \" \" ) else : print ( grid [ row ][ col ], end = \" \" ) print () Compare it to the more naive, less greedy approach below. Python3 Solution for depth-first approach def flood ( grid , r , c , depth , x , y ): # Recursive algorithm (function that calls itself) that goes deep first if depth == 1 : return for ( i , j ) in [( r - 1 , c ), ( r + 1 , c ), ( r , c - 1 ), ( r , c + 1 )]: if i < x and i >= 0 and j < y and j >= 0 \\ and grid [ i ][ j ] >= 0 and grid [ i ][ j ] < depth - 1 : flood ( grid , i , j , depth - 1 , x , y ) rows , cols , depth = [ int ( i ) for i in input () . split ()] grid = [[ 0 ] * cols ] * rows water_r = 0 water_c = 0 for row in range ( rows ): s = input () . split () for col in range ( cols ): if s [ col ] == \"X\" : grid [ row ][ col ] = - 1 elif s [ col ] == \".\" : grid [ row ][ col ] = 0 else : grid [ row ][ col ] = int ( s [ col ]) water_r = row water_c = col flood ( grid , water_r , water_c , depth , rows , cols ) for row in range ( rows ): for col in range ( cols ): if grid [ row ][ col ] == 0 : print ( '.' , end = \" \" ) else : print ( grid [ row ][ col ], end = \" \" ) print ()","title":"A more efficient, greedy approach"},{"location":"Recess_Week_Challenge_Stuff/q4_hints/","text":"Final Question Hints # Try to use hints only when you really need help! The hints are arranged in order. Hint 1 You may find Dynamic Programming to be useful. It is up to you to find out how to use it. (Read the basic concepts section).","title":"Final Question Hints"},{"location":"Recess_Week_Challenge_Stuff/q4_hints/#final-question-hints","text":"Try to use hints only when you really need help! The hints are arranged in order. Hint 1 You may find Dynamic Programming to be useful. It is up to you to find out how to use it. (Read the basic concepts section).","title":"Final Question Hints"},{"location":"Recess_Week_Challenge_Stuff/teaser_hints/","text":"Teaser Hints # Try to use hints only when you really need help! The hints are arranged in order. Hint 1 This looks like a sorting problem. It might help to understand what sorting algorithms are out there. You can compare the speed of the algorithms by looking at their time complexities. Insertion Sort Merge Sort Quick Sort Heap Sort But wait! There might be better solutions! Many programming languages actually have their own standard implementations to help you to sort lists! Programming Language Implementation Python list.sort() or sorted() C++ std::sort from algorithm standard library Java Collections.sort() The real problem is these standard implementations usually only sort single numbers, but we have to sort a tuple of r, g and b... is there some way around that? Hint 2 Consider the followings notes/questions: Usually sorting allows us to sort lists of single numbers Is it possible to convert the tuple for r, g and b into a form that is more friendly for sorting? Or perhaps do the standard implementations allow you to use your own method to compare between two elements? Hint 3 Consider the following questions: Is there a way to combine r, g and b into a single number? (Maybe some arithmetic? Addition?) But how do we combine them in such a way that we can get the exact same r, g and b values back after sorting? Maybe we can think about how we can combine them to a number that reflects the relative importance of each colour component (i.e. r is more important than g and b)?","title":"Teaser Hints"},{"location":"Recess_Week_Challenge_Stuff/teaser_hints/#teaser-hints","text":"Try to use hints only when you really need help! The hints are arranged in order. Hint 1 This looks like a sorting problem. It might help to understand what sorting algorithms are out there. You can compare the speed of the algorithms by looking at their time complexities. Insertion Sort Merge Sort Quick Sort Heap Sort But wait! There might be better solutions! Many programming languages actually have their own standard implementations to help you to sort lists! Programming Language Implementation Python list.sort() or sorted() C++ std::sort from algorithm standard library Java Collections.sort() The real problem is these standard implementations usually only sort single numbers, but we have to sort a tuple of r, g and b... is there some way around that? Hint 2 Consider the followings notes/questions: Usually sorting allows us to sort lists of single numbers Is it possible to convert the tuple for r, g and b into a form that is more friendly for sorting? Or perhaps do the standard implementations allow you to use your own method to compare between two elements? Hint 3 Consider the following questions: Is there a way to combine r, g and b into a single number? (Maybe some arithmetic? Addition?) But how do we combine them in such a way that we can get the exact same r, g and b values back after sorting? Maybe we can think about how we can combine them to a number that reflects the relative importance of each colour component (i.e. r is more important than g and b)?","title":"Teaser Hints"},{"location":"Recess_Week_Challenge_Stuff/teaser_sols/","text":"Teaser Solutions (SPOILER!) # This page shows the solutions for the teaser problem. If you that is not what you intended, turn back now! Time complexity: O(n*log(n)) for n = Number of Sheep This question is quite obviously a sorting problem. We just need to sort the sheep according to which is more red, then more blue, then more green. For many programming languages, there are well-established sorting functions for lists (they usually have well-established methods for common tasks). The main problem most sorting functions sort only single numbers (or is it?), whereas we have a tuple \\((r, g, b)\\) . Converting the tuple to a single number # A simple approach is to simply flatten the tuple \\((r, g, b)\\) into a single number. We can convert the rgb value to be a 3-digit base-256 number (usually our numbers are in base-10). We can use this base-256 number to also represent the relative importances of \\(r\\) , \\(g\\) and \\(b\\) . Since \\(b\\) is the least important, we take it to be the 1st digit of the base-256 number Since \\(g\\) is the 2nd most important, we take it to be the 2nd digit of the base-256 number Since \\(r\\) is the most important, we take it to be the 3rd digit of the base-256 number To perform the conversion, we can just simply do \\(rgb = 256*256*r + 256*g + b\\) . After converting to the base-256 number, we can just use the standard sort functions to sort our tuple. However, we need to remember to convert the base-256 number back to \\((r, g, b)\\) format for printing out the result. Thats not too difficult, we can do \\(r = sheep \\div (256 * 256))\\) \\(g = (sheep \\mod (256 * 256)) \\div 256)\\) \\(b = sheep \\mod 256\\) Python3 Solution for Tuple Conversion (List) s = int ( input ()) sheeps = [] for i in range ( s ): [ r , g , b ] = input () . split () sheeps . append ( 256 * 256 * int ( r ) + 256 * int ( g ) + int ( b )) sheeps . sort ( reverse = True ) for sheep in sheeps : r = int ( sheep / ( 256 * 256 )) g = int ( sheep % ( 256 * 256 ) / 256 ) b = int ( sheep % 256 ) print ( r , g , b ) C++14 Solution for Tuple Conversion (List) #include <algorithm> #include <iostream> #include <vector> int main () { int s ; std :: cin >> s ; std :: vector < int > sheeps ( s ); for ( auto it { sheeps . begin () }; it != sheeps . end () ; ++ it ) { int r , g , b ; std :: cin >> r >> g >> b ; int rgb { 256 * 256 * r + 256 * g + b }; * it = rgb ; } std :: sort ( sheeps . begin (), sheeps . end ()); for ( auto it { sheeps . rbegin () }; it != sheeps . rend (); ++ it ) { int r { * it / ( 256 * 256 ) }; int g { * it % ( 256 * 256 ) / 256 }; int b { * it % 256 }; std :: cout << r << ' ' << g << ' ' << b << '\\n' ; } } Python3 Solution for Tuple Conversion (Dictionary) s = int ( input ()) sheeps = {} for i in range ( s ): [ r , g , b ] = input () . split () rgb = 256 * 256 * int ( r ) + 256 * int ( g ) + int ( b ) if rgb not in sheeps : sheeps [ rgb ] = 1 else : sheeps [ rgb ] += 1 for rgb , count in sorted ( sheeps . items (), reverse = True ): r = int ( rgb / ( 256 * 256 )) g = int ( rgb % ( 256 * 256 ) / 256 ) b = int ( rgb % 256 ) for i in range ( count ): print ( r , g , b ) C++14 Solution for Tuple Conversion (Hashmap) #include <algorithm> #include <iostream> #include <vector> int main () { int s ; std :: cin >> s ; std :: vector < int > sheeps ( s ); for ( auto it { sheeps . begin () }; it != sheeps . end () ; ++ it ) { int r , g , b ; std :: cin >> r >> g >> b ; int rgb { 256 * 256 * r + 256 * g + b }; * it = rgb ; } std :: sort ( sheeps . begin (), sheeps . end ()); for ( auto it { sheeps . rbegin () }; it != sheeps . rend (); ++ it ) { int r { * it / ( 256 * 256 ) }; int g { * it % ( 256 * 256 ) / 256 }; int b { * it % 256 }; std :: cout << r << ' ' << g << ' ' << b << '\\n' ; } } Custom Comparators # If we look closely, most sorting functions allow you to use a custom comparator to compare two elements in a list. So we can simply do that. Also, most sorting functions allow you to reverse the sorting direction. Or you could just iterate from the back of the list so that we get the larger numbers first. Python3 Solution for Custom Comparator from operator import itemgetter s = int ( input ()) sheeps = [] for i in range ( s ): [ r , g , b ] = input () . split () sheeps . append (( int ( r ), int ( g ), int ( b ))) # Add our r, g and b values into a list of tuples # itemgetter allows us to sort by the first element first, then the second element # then the third element # reverse=True reverse the direction of the sort of the list for rgb in sorted ( sheeps , key = itemgetter ( 0 , 1 , 2 ), reverse = True ): r , g , b = rgb print ( r , g , b ) C++14 Solution for Custom Comparator #include <array> #include <algorithm> #include <iostream> #include <vector> // Custom function to compare our r, g, b values stored in an array // Function will have to return true if first element is smaller(less r, g or b) than second element // Return false otherwise bool cmp ( const std :: array < int , 3 >& a , const std :: array < int , 3 >& b ) { if ( a . at ( 0 ) > b . at ( 0 )) // If first element has more red { return false ; } else if ( a . at ( 1 ) > b . at ( 1 ) && a . at ( 0 ) == b . at ( 0 )) // If equally red, but first is more green { return false ; } else if ( a . at ( 2 ) >= b . at ( 2 ) && a . at ( 0 ) == b . at ( 0 ) && a . at ( 1 ) == b . at ( 1 )) // If equally red and green, but first is more or equally blue { return false ; } else // first element now has to be more red/green/blue than other element { return true ; } } int main () { int s ; std :: cin >> s ; std :: vector < std :: array < int , 3 >> sheeps ( s ); // Create a vector of size s to hold our rgb array for ( auto it { sheeps . begin () }; it != sheeps . end () ; ++ it ) { // Iterate through vector and assign each vector element to an array int r , g , b ; std :: cin >> r >> g >> b ; // Read our r, g, b values from input * it = std :: array < int , 3 > { r , g , b }; // Store r, g, b values into array } std :: sort ( sheeps . begin (), sheeps . end (), cmp ); // Sort vector using our custom comparator for ( auto it { sheeps . rbegin () }; it != sheeps . rend (); ++ it ) { // Iterate from the back which has sheep with larger r, g, b values // Then extract our r, g and b values and print them int r { it -> at ( 0 ) }; int g { it -> at ( 1 ) }; int b { it -> at ( 2 ) }; std :: cout << r << ' ' << g << ' ' << b << '\\n' ; } }","title":"Teaser Solutions (SPOILER!)"},{"location":"Recess_Week_Challenge_Stuff/teaser_sols/#teaser-solutions-spoiler","text":"This page shows the solutions for the teaser problem. If you that is not what you intended, turn back now! Time complexity: O(n*log(n)) for n = Number of Sheep This question is quite obviously a sorting problem. We just need to sort the sheep according to which is more red, then more blue, then more green. For many programming languages, there are well-established sorting functions for lists (they usually have well-established methods for common tasks). The main problem most sorting functions sort only single numbers (or is it?), whereas we have a tuple \\((r, g, b)\\) .","title":"Teaser Solutions (SPOILER!)"},{"location":"Recess_Week_Challenge_Stuff/teaser_sols/#converting-the-tuple-to-a-single-number","text":"A simple approach is to simply flatten the tuple \\((r, g, b)\\) into a single number. We can convert the rgb value to be a 3-digit base-256 number (usually our numbers are in base-10). We can use this base-256 number to also represent the relative importances of \\(r\\) , \\(g\\) and \\(b\\) . Since \\(b\\) is the least important, we take it to be the 1st digit of the base-256 number Since \\(g\\) is the 2nd most important, we take it to be the 2nd digit of the base-256 number Since \\(r\\) is the most important, we take it to be the 3rd digit of the base-256 number To perform the conversion, we can just simply do \\(rgb = 256*256*r + 256*g + b\\) . After converting to the base-256 number, we can just use the standard sort functions to sort our tuple. However, we need to remember to convert the base-256 number back to \\((r, g, b)\\) format for printing out the result. Thats not too difficult, we can do \\(r = sheep \\div (256 * 256))\\) \\(g = (sheep \\mod (256 * 256)) \\div 256)\\) \\(b = sheep \\mod 256\\) Python3 Solution for Tuple Conversion (List) s = int ( input ()) sheeps = [] for i in range ( s ): [ r , g , b ] = input () . split () sheeps . append ( 256 * 256 * int ( r ) + 256 * int ( g ) + int ( b )) sheeps . sort ( reverse = True ) for sheep in sheeps : r = int ( sheep / ( 256 * 256 )) g = int ( sheep % ( 256 * 256 ) / 256 ) b = int ( sheep % 256 ) print ( r , g , b ) C++14 Solution for Tuple Conversion (List) #include <algorithm> #include <iostream> #include <vector> int main () { int s ; std :: cin >> s ; std :: vector < int > sheeps ( s ); for ( auto it { sheeps . begin () }; it != sheeps . end () ; ++ it ) { int r , g , b ; std :: cin >> r >> g >> b ; int rgb { 256 * 256 * r + 256 * g + b }; * it = rgb ; } std :: sort ( sheeps . begin (), sheeps . end ()); for ( auto it { sheeps . rbegin () }; it != sheeps . rend (); ++ it ) { int r { * it / ( 256 * 256 ) }; int g { * it % ( 256 * 256 ) / 256 }; int b { * it % 256 }; std :: cout << r << ' ' << g << ' ' << b << '\\n' ; } } Python3 Solution for Tuple Conversion (Dictionary) s = int ( input ()) sheeps = {} for i in range ( s ): [ r , g , b ] = input () . split () rgb = 256 * 256 * int ( r ) + 256 * int ( g ) + int ( b ) if rgb not in sheeps : sheeps [ rgb ] = 1 else : sheeps [ rgb ] += 1 for rgb , count in sorted ( sheeps . items (), reverse = True ): r = int ( rgb / ( 256 * 256 )) g = int ( rgb % ( 256 * 256 ) / 256 ) b = int ( rgb % 256 ) for i in range ( count ): print ( r , g , b ) C++14 Solution for Tuple Conversion (Hashmap) #include <algorithm> #include <iostream> #include <vector> int main () { int s ; std :: cin >> s ; std :: vector < int > sheeps ( s ); for ( auto it { sheeps . begin () }; it != sheeps . end () ; ++ it ) { int r , g , b ; std :: cin >> r >> g >> b ; int rgb { 256 * 256 * r + 256 * g + b }; * it = rgb ; } std :: sort ( sheeps . begin (), sheeps . end ()); for ( auto it { sheeps . rbegin () }; it != sheeps . rend (); ++ it ) { int r { * it / ( 256 * 256 ) }; int g { * it % ( 256 * 256 ) / 256 }; int b { * it % 256 }; std :: cout << r << ' ' << g << ' ' << b << '\\n' ; } }","title":"Converting the tuple to a single number"},{"location":"Recess_Week_Challenge_Stuff/teaser_sols/#custom-comparators","text":"If we look closely, most sorting functions allow you to use a custom comparator to compare two elements in a list. So we can simply do that. Also, most sorting functions allow you to reverse the sorting direction. Or you could just iterate from the back of the list so that we get the larger numbers first. Python3 Solution for Custom Comparator from operator import itemgetter s = int ( input ()) sheeps = [] for i in range ( s ): [ r , g , b ] = input () . split () sheeps . append (( int ( r ), int ( g ), int ( b ))) # Add our r, g and b values into a list of tuples # itemgetter allows us to sort by the first element first, then the second element # then the third element # reverse=True reverse the direction of the sort of the list for rgb in sorted ( sheeps , key = itemgetter ( 0 , 1 , 2 ), reverse = True ): r , g , b = rgb print ( r , g , b ) C++14 Solution for Custom Comparator #include <array> #include <algorithm> #include <iostream> #include <vector> // Custom function to compare our r, g, b values stored in an array // Function will have to return true if first element is smaller(less r, g or b) than second element // Return false otherwise bool cmp ( const std :: array < int , 3 >& a , const std :: array < int , 3 >& b ) { if ( a . at ( 0 ) > b . at ( 0 )) // If first element has more red { return false ; } else if ( a . at ( 1 ) > b . at ( 1 ) && a . at ( 0 ) == b . at ( 0 )) // If equally red, but first is more green { return false ; } else if ( a . at ( 2 ) >= b . at ( 2 ) && a . at ( 0 ) == b . at ( 0 ) && a . at ( 1 ) == b . at ( 1 )) // If equally red and green, but first is more or equally blue { return false ; } else // first element now has to be more red/green/blue than other element { return true ; } } int main () { int s ; std :: cin >> s ; std :: vector < std :: array < int , 3 >> sheeps ( s ); // Create a vector of size s to hold our rgb array for ( auto it { sheeps . begin () }; it != sheeps . end () ; ++ it ) { // Iterate through vector and assign each vector element to an array int r , g , b ; std :: cin >> r >> g >> b ; // Read our r, g, b values from input * it = std :: array < int , 3 > { r , g , b }; // Store r, g, b values into array } std :: sort ( sheeps . begin (), sheeps . end (), cmp ); // Sort vector using our custom comparator for ( auto it { sheeps . rbegin () }; it != sheeps . rend (); ++ it ) { // Iterate from the back which has sheep with larger r, g, b values // Then extract our r, g and b values and print them int r { it -> at ( 0 ) }; int g { it -> at ( 1 ) }; int b { it -> at ( 2 ) }; std :: cout << r << ' ' << g << ' ' << b << '\\n' ; } }","title":"Custom Comparators"}]}